import {IGeneratorController} from "../../extensions/generator-controller.interface";
import {GetEndpointData, GetProject} from "../utility/utility";
import {ClassDeclaration, OptionalKind, ParameterDeclarationStructure, Scope, SourceFile} from "ts-morph";
import {ERouteMethod} from "waxen/dist/route-method.enum";


function GetApiFiles(files: SourceFile[]): ClassDeclaration[] {
    let classes = [];
    for (let file of files) {
        if (file.getClasses().length > 0)
            for (let c of file.getClasses()) {
                if (c.getDecorator('Api')) {
                    classes.push(c);
                }
            }
    }
    return classes;
}

export function GenerateApis(tsConfigPath: string) {
    console.log(`Reading tsconfig at: ${tsConfigPath}`)

    const project = GetProject(tsConfigPath);
    let files = project.getSourceFiles();
    //TODO Check controller classes can not have the same name
    console.log('Api files: ');
    let apiClasses = GetApiFiles(files);
    apiClasses.forEach(c => console.log('   - ' + c.getName()));
    apiClasses.forEach(c => GenerateApi(c, GetEndpointData(c, 'Api')));
    project.saveSync();
    return;
};

export function GenerateApi(controller: ClassDeclaration, controllerInfo: IGeneratorController): IGeneratorController {
    console.log('Generating ' + controller.getName() + '....');
    try {
        GenerateEndpoints(controllerInfo, controller);
        controller.formatText();
        controller.getSourceFile().fixMissingImports();
        controller.getSourceFile().saveSync();
        return controllerInfo;
    } catch (error) {
        console.error(error);
        console.log(controller.getName() + ' could not be generated.');
    }
}

function GenerateEndpoints(controllerInfo: IGeneratorController, controller: ClassDeclaration) {
    controllerInfo.className = controller.getName();
    controller.getMethods().forEach(m => m.remove());
    if (!controller.getSourceFile().getImportDeclarations()
        .find(c => c.getNamedImports()
            .find(m => m.getName() == 'IHttpCaller'))) {
        controller.getSourceFile().addImportDeclaration(
            {
                moduleSpecifier: "waxen/dist/client/IHttpCaller",
                defaultImport: "{IHttpCaller}"
            });
    }

    controller.getMethods().forEach(m => console.log(m.getName()));
    for (let routeInfo of controllerInfo.routes) {
        let parameters: OptionalKind<ParameterDeclarationStructure>[] = [];

        parameters.push({name: "client", type: 'IHttpCaller'});
        parameters.push(...routeInfo.paramTypeOrder.map((p) => {
            return {name: p.key, type: p.type}
        }));

        if (routeInfo.method == ERouteMethod.PUT || routeInfo.method == ERouteMethod.POST) {
            parameters.push({name: "body", type: routeInfo.requestTypeName});
        }

        let returnType = 'Promise<' + routeInfo.responseTypeName + '>';

        let controllerBasePath = controllerInfo.basepath.length > 0 ? `/${controllerInfo.basepath}` : '';

        let completePathWithParams = routeInfo.paramTypeOrder.length > 0 ?
            `${controllerBasePath}/'${routeInfo.path}/'` + '+ `' + routeInfo.paramTypeOrder.map(m => "${ " + m.key + "}").join('/') + '`'
            : `'${routeInfo.path}'`;
        let request: string;
        switch (routeInfo.method) {
            case ERouteMethod.GET:
                request = `GET(${completePathWithParams})`;
                break;
            case ERouteMethod.DELETE:
                request = `DELETE(${completePathWithParams})`;
                break;
            case ERouteMethod.PUT:
                request = `PUT(${completePathWithParams}${routeInfo.requestTypeName != 'void' ? `, body` : ''})`;
                break;
            case ERouteMethod.POST:
                request = `POST(${completePathWithParams}${routeInfo.requestTypeName != 'void' ? `, body` : ''})`;
                break;
        }

        let statements: string[] = [];
        statements.push(`return new Promise<${routeInfo.responseTypeName}>(async (resolve) => {`);
        statements.push(`const response = await client.${request};`);
        statements.push('response.subscribe(data => {');
        statements.push(`resolve(data as ${routeInfo.responseTypeName})`);
        statements.push(...[
            '}, (err) => {',
            'console.error(err);',
            'resolve(undefined);',
            '});',
            '});'
        ])

        let method = controller.addMethod({
            isAbstract: false,
            docs: ['<=== Autogenerated callable endpoint ===>'],
            isAsync: true,
            name: routeInfo.routeName,
            statements: statements,
            parameters: parameters,
            returnType: returnType,
            scope: Scope.Public
        });

    }
}
