import {ClassDeclaration, Scope, SourceFile} from "ts-morph";
import {IGeneratorController} from "../../extensions/generator-controller.interface";
import {cleanStr, GetEndpointData, GetProject} from "../utility/utility";
import {Config} from "../main";


function GetControllerFiles(files: SourceFile[]): ClassDeclaration[] {
    let classes = [];
    for (let file of files) {
        if (file.getClasses().length > 0)
            for (let c of file.getClasses()) {
                if (c.getDecorator('Controller')) {
                    classes.push(c);
                }
            }
    }
    return classes;
}


export function GenerateControllers(tsConfigPath: string): IGeneratorController[] {
    console.log(`Reading tsconfig at: ${tsConfigPath}`)
    const project = GetProject(tsConfigPath);
    let files = project.getSourceFiles();
    //TODO Check controller classes can not have the same name
    console.log('Controller files: ');
    let controllerClasses = GetControllerFiles(files);
    controllerClasses.forEach(c => console.log('   - ' + c.getName()));
    let controllerData: IGeneratorController[] = [];
    controllerClasses.forEach(c => controllerData.push(GenerateController(c, GetEndpointData(c))));
    project.saveSync();
    return controllerData;
};



function GenerateRouteFunctions(controllerInfo: IGeneratorController, controller: ClassDeclaration) {
    controllerInfo.className = controller.getName();
    for (let routeInfo of controllerInfo.routes) {
        let method = controller.getMethod(routeInfo.routeName);

        let authDecorator = method?.getDecorator('Security')
        if (authDecorator) {
            let anoEnabled = authDecorator.getArguments()[0].getText() == 'true';
            let permissions: string[] = [];
            let current = 1;
            while (current < authDecorator.getArguments().length) {
                permissions.push(cleanStr(authDecorator.getArguments()[current].getText()));
                current++;
            }
            routeInfo.authentication = {anoEnabled: anoEnabled, permissions: permissions};
        };
        routeInfo.provideRequest = method?.getDecorator('ProvideRequest') != undefined;

        let parameters = [
            {name: 'reqBody', type: routeInfo.requestTypeName}]
            .concat(routeInfo.authentication ?
                {name: 'user', type: Config.c.authentication?.UserType ? Config.c.authentication?.UserType : 'any'} :
                [])
            .concat(routeInfo.provideRequest ?
                {name: 'request', type: 'any'} :
                [])
            .concat(routeInfo.paramTypeOrder.map((p) => {
                return {name: p.key, type: p.type}
            }));
        let returnType = 'Promise<' + routeInfo.responseTypeName + '>';

        if (!method) {
            controller.addMethod({
                isAbstract: false,
                docs: ['TODO This method is auto generated by waxen generator. Please end it.'],
                isAsync: true,
                name: routeInfo.routeName,
                statements: [`throw new Error('Route ${routeInfo.routeName} is not implemented');`],
                parameters: parameters,
                returnType: returnType,
                scope: Scope.Public
            });
        } else {
            method.setIsAbstract(false);
            method.setIsAsync(true);
            method.getParameters().forEach(p => p.remove());
            method.addParameters(parameters);
            method.setReturnType(returnType);
            method.setScope(Scope.Public);
        }

    }
}

export function GenerateController(controller: ClassDeclaration, controllerInfo: IGeneratorController): IGeneratorController {
    console.log('Generating ' + controller.getName() + '....');
    try {
        GenerateRouteFunctions(controllerInfo, controller);
        controller.formatText();
        controller.getSourceFile().fixMissingImports();
        controller.getSourceFile().saveSync();
        return controllerInfo;
    } catch (error) {
        console.error(error);
        console.log(controller.getName() + ' could not be generated.');
    }
}
